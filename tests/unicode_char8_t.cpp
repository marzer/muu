// This file is a part of muu and is subject to the the terms of the MIT license.
// Copyright (c) 2020 Mark Gillard <mark.gillard@outlook.com.au>
// See https://github.com/marzer/muu/blob/master/LICENSE for the full license text.
// SPDX-License-Identifier: MIT
//-----
// this file was generated by generate_unicode_functions.py - do not modify it directly

#include "tests.h"
#include "unicode.h"
#include "../include/muu/strings.h"

#ifdef __cpp_char8_t

TEST_CASE("unicode - is_ascii (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_ascii);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ u8'\0', u8'\x7F' },
	};
	for (const auto& r : true_ranges)
	{
		REQUIRE(in(fn, r));
		REQUIRE(in_only<1>(fn, r));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ 0x80u, 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_unicode (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_unicode);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ 0x80u, 0xFFu },
	};
	for (const auto& r : true_ranges)
	{
		REQUIRE(in(fn, r));
		REQUIRE(in_only<1>(fn, r));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', u8'\x7F' },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_ascii_whitespace (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_ascii_whitespace);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ u8'\t', u8'\r' },
	};
	for (const auto& r : true_ranges)
	{
		REQUIRE(in(fn, r));
		REQUIRE(in_only<2>(fn, r));
		REQUIRE(in_only<7>(fn, r));
	}
	static constexpr char8_t true_values[] = 
	{
		u8' ',
	};
	for (auto v : true_values)
	{
		REQUIRE(fn(v));
		REQUIRE(in_only<2>(fn, v));
		REQUIRE(in_only<7>(fn, v));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', u8'\b' }, { u8'\x0E', u8'\x1F' }, { u8'!', 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_unicode_whitespace (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_unicode_whitespace);
 
	// values which should return true
	static constexpr char8_t true_values[] = 
	{
		0x85u, 0xA0u,
	};
	for (auto v : true_values)
	{
		REQUIRE(fn(v));
		REQUIRE(in_only<2>(fn, v));
		REQUIRE(in_only<7>(fn, v));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', 0x84u }, { 0x86u, 0x9Fu }, { 0xA1u, 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_ascii_letter (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_ascii_letter);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ u8'A', u8'Z' }, { u8'a', u8'z' },
	};
	for (const auto& r : true_ranges)
	{
		REQUIRE(in(fn, r));
		REQUIRE(in_only<3>(fn, r));
		REQUIRE(in_only<7>(fn, r));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', u8'@' }, { u8'[', u8'`' }, { u8'{', 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_unicode_letter (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_unicode_letter);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ 0xC0u, 0xD6u }, { 0xD8u, 0xF6u }, { 0xF8u, 0xFFu },
	};
	for (const auto& r : true_ranges)
	{
		REQUIRE(in(fn, r));
		REQUIRE(in_only<3>(fn, r));
		REQUIRE(in_only<7>(fn, r));
	}
	static constexpr char8_t true_values[] = 
	{
		0xAAu, 0xB5u, 0xBAu,
	};
	for (auto v : true_values)
	{
		REQUIRE(fn(v));
		REQUIRE(in_only<3>(fn, v));
		REQUIRE(in_only<7>(fn, v));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', 0xA9u }, { 0xABu, 0xB4u }, { 0xB6u, 0xB9u },
		{ 0xBBu, 0xBFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
	static constexpr char8_t false_values[] = 
	{
		0xD7u, 0xF7u,
	};
	for (auto v : false_values)
		REQUIRE(!fn(v));
}

TEST_CASE("unicode - is_ascii_number (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_ascii_number);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ u8'0', u8'9' },
	};
	for (const auto& r : true_ranges)
	{
		REQUIRE(in(fn, r));
		REQUIRE(in_only<4>(fn, r));
		REQUIRE(in_only<7>(fn, r));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', u8'/' }, { u8':', 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_unicode_number (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_unicode_number);
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_ascii_hyphen (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_ascii_hyphen);
 
	// values which should return true
	static constexpr char8_t true_values[] = 
	{
		u8'-',
	};
	for (auto v : true_values)
	{
		REQUIRE(fn(v));
		REQUIRE(in_only<5>(fn, v));
		REQUIRE(in_only<7>(fn, v));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', u8',' }, { u8'.', 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_unicode_hyphen (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_unicode_hyphen);
 
	// values which should return true
	static constexpr char8_t true_values[] = 
	{
		0xADu,
	};
	for (auto v : true_values)
	{
		REQUIRE(fn(v));
		REQUIRE(in_only<5>(fn, v));
		REQUIRE(in_only<7>(fn, v));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', 0xACu }, { 0xAEu, 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_combining_mark (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_combining_mark);
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_octal_digit (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_octal_digit);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ u8'0', u8'7' },
	};
	for (const auto& r : true_ranges)
		REQUIRE(in(fn, r));
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', u8'/' }, { u8'8', 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_decimal_digit (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_decimal_digit);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ u8'0', u8'9' },
	};
	for (const auto& r : true_ranges)
		REQUIRE(in(fn, r));
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', u8'/' }, { u8':', 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_hexadecimal_digit (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_hexadecimal_digit);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ u8'0', u8'9' }, { u8'A', u8'F' }, { u8'a', u8'f' },
	};
	for (const auto& r : true_ranges)
		REQUIRE(in(fn, r));
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', u8'/' }, { u8':', u8'@' }, { u8'G', u8'`' },
		{ u8'g', 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
}

TEST_CASE("unicode - is_uppercase (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_uppercase);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ u8'A', u8'Z' }, { 0xC0u, 0xD6u }, { 0xD8u, 0xDEu },
	};
	for (const auto& r : true_ranges)
	{
		REQUIRE(in(fn, r));
		REQUIRE(in_only<6>(fn, r));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', u8'@' }, { u8'[', 0xBFu }, { 0xDFu, 0xFFu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
	static constexpr char8_t false_values[] = 
	{
		0xD7u,
	};
	for (auto v : false_values)
		REQUIRE(!fn(v));
}

TEST_CASE("unicode - is_lowercase (char8_t)")
{
	using namespace impl;
	static constexpr auto fn = static_cast<code_unit_func<char8_t>*>(is_lowercase);
 
	// values which should return true
	static constexpr code_unit_range<uint32_t> true_ranges[] = 
	{
		{ u8'a', u8'z' }, { 0xDFu, 0xF6u }, { 0xF8u, 0xFFu },
	};
	for (const auto& r : true_ranges)
	{
		REQUIRE(in(fn, r));
		REQUIRE(in_only<6>(fn, r));
	}
	static constexpr char8_t true_values[] = 
	{
		0xAAu, 0xB5u, 0xBAu,
	};
	for (auto v : true_values)
	{
		REQUIRE(fn(v));
		REQUIRE(in_only<6>(fn, v));
	}
 
	// values which should return false
	static constexpr code_unit_range<uint32_t> false_ranges[] = 
	{
		{ u8'\0', u8'`' }, { u8'{', 0xA9u }, { 0xABu, 0xB4u },
		{ 0xB6u, 0xB9u }, { 0xBBu, 0xDEu },
	};
	for (const auto& r : false_ranges)
		REQUIRE(not_in(fn, r));
	static constexpr char8_t false_values[] = 
	{
		0xF7u,
	};
	for (auto v : false_values)
		REQUIRE(!fn(v));
}

template <>
struct code_unit_func_group<char8_t, 1>
{
	static constexpr code_unit_func<char8_t>* functions[] =
	{
		is_ascii,
		is_unicode,
	};
};

template <>
struct code_unit_func_group<char8_t, 2>
{
	static constexpr code_unit_func<char8_t>* functions[] =
	{
		is_ascii_whitespace,
		is_unicode_whitespace,
	};
};

template <>
struct code_unit_func_group<char8_t, 7>
{
	static constexpr code_unit_func<char8_t>* functions[] =
	{
		is_ascii_hyphen,
		is_ascii_letter,
		is_ascii_number,
		is_ascii_whitespace,
		is_combining_mark,
		is_unicode_hyphen,
		is_unicode_letter,
		is_unicode_number,
		is_unicode_whitespace,
	};
};

template <>
struct code_unit_func_group<char8_t, 3>
{
	static constexpr code_unit_func<char8_t>* functions[] =
	{
		is_ascii_letter,
		is_unicode_letter,
	};
};

template <>
struct code_unit_func_group<char8_t, 4>
{
	static constexpr code_unit_func<char8_t>* functions[] =
	{
		is_ascii_number,
		is_unicode_number,
	};
};

template <>
struct code_unit_func_group<char8_t, 5>
{
	static constexpr code_unit_func<char8_t>* functions[] =
	{
		is_ascii_hyphen,
		is_unicode_hyphen,
	};
};

template <>
struct code_unit_func_group<char8_t, 6>
{
	static constexpr code_unit_func<char8_t>* functions[] =
	{
		is_lowercase,
		is_uppercase,
	};
};

#endif // __cpp_char8_t
