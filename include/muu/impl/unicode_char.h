// This file is a part of muu and is subject to the the terms of the MIT license.
// Copyright (c) 2020 Mark Gillard <mark.gillard@outlook.com.au>
// See https://github.com/marzer/muu/blob/master/LICENSE for the full license text.
// SPDX-License-Identifier: MIT
//-----
// this file was generated by generate_unicode_functions.py - do not modify it directly

/// \file
/// \attention These are not the droids you are looking for. Try \ref strings instead.

#pragma once
#ifdef __cpp_char8_t
	#include "../../muu/impl/unicode_char8_t.h"
#else
	#include "../../muu/impl/unicode_unsigned_char.h"
#endif

MUU_PUSH_WARNINGS
MUU_DISABLE_SPAM_WARNINGS

MUU_NAMESPACE_START
{
	/// \brief		Returns true if a character is within the ASCII range.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_ascii(char c) noexcept
	{
		using namespace impl;
		return is_ascii(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is not within the ASCII range (i.e. it is a part greater Unicode).
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_unicode(char c) noexcept
	{
		using namespace impl;
		return is_unicode(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a whitespace code point from the ASCII range.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_ascii_whitespace(char c) noexcept
	{
		using namespace impl;
		return is_ascii_whitespace(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a whitespace code point from outside the ASCII range.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_unicode_whitespace(char c) noexcept
	{
		using namespace impl;
		return is_unicode_whitespace(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a whitespace code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_whitespace(char c) noexcept
	{
		using namespace impl;
		return is_whitespace(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is not a whitespace code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_not_whitespace(char c) noexcept
	{
		using namespace impl;
		return is_not_whitespace(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a letter code point from the ASCII range.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_ascii_letter(char c) noexcept
	{
		using namespace impl;
		return is_ascii_letter(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a letter code point from outside the ASCII range.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_unicode_letter(char c) noexcept
	{
		using namespace impl;
		return is_unicode_letter(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a letter code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_letter(char c) noexcept
	{
		using namespace impl;
		return is_letter(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a number code point from the ASCII range.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_ascii_number(char c) noexcept
	{
		using namespace impl;
		return is_ascii_number(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a number code point from outside the ASCII range.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_unicode_number(char c) noexcept
	{
		(void)c;
		return false;
	}

	/// \brief		Returns true if a character is a number code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_number(char c) noexcept
	{
		using namespace impl;
		return is_number(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a hyphen code point from the ASCII range.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_ascii_hyphen(char c) noexcept
	{
		using namespace impl;
		return is_ascii_hyphen(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a hyphen code point from outside the ASCII range.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_unicode_hyphen(char c) noexcept
	{
		using namespace impl;
		return is_unicode_hyphen(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a hyphen code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_hyphen(char c) noexcept
	{
		using namespace impl;
		return is_hyphen(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a combining mark code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_combining_mark(char c) noexcept
	{
		(void)c;
		return false;
	}

	/// \brief		Returns true if a character is an octal digit code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_octal_digit(char c) noexcept
	{
		using namespace impl;
		return is_octal_digit(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a decimal digit code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_decimal_digit(char c) noexcept
	{
		using namespace impl;
		return is_decimal_digit(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a hexadecimal digit code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_hexadecimal_digit(char c) noexcept
	{
		using namespace impl;
		return is_hexadecimal_digit(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is an uppercase code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_uppercase(char c) noexcept
	{
		using namespace impl;
		return is_uppercase(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is an lowercase code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_lowercase(char c) noexcept
	{
		using namespace impl;
		return is_lowercase(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is a code point boundary.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_code_point_boundary(char c) noexcept
	{
		using namespace impl;
		return is_code_point_boundary(static_cast<char_unicode_t>(c));
	}

	/// \brief		Returns true if a character is in-and-of-itself a valid code point.
	/// \ingroup	characters
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_code_point(char c) noexcept
	{
		using namespace impl;
		return is_code_point(static_cast<char_unicode_t>(c));
	}

}
MUU_NAMESPACE_END

MUU_POP_WARNINGS // MUU_DISABLE_SPAM_WARNINGS
