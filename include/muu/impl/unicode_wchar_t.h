// This file is a part of muu and is subject to the the terms of the MIT license.
// Copyright (c) 2020 Mark Gillard <mark.gillard@outlook.com.au>
// See https://github.com/marzer/muu/blob/master/LICENSE for the full license text.
// SPDX-License-Identifier: MIT
//-----
// this file was generated by generate_unicode_functions.py - do not modify it directly

/// \file
/// \attention These are not the droids you are looking for. Try \ref strings instead.

#pragma once
#include "../../muu/preprocessor.h"
#include MUU_MAKE_STRING_2(MUU_CONCAT(MUU_CONCAT(../../muu/impl/unicode_char, MUU_WCHAR_BITS), _t.h))

MUU_NAMESPACE_START
{
	/// \brief		Returns true if a wide character is whitespace from the ASCII range.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_ascii_whitespace(wchar_t c) noexcept
	{
		using namespace impl;
		return is_ascii_whitespace(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is whitespace from outside the ASCII range.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_non_ascii_whitespace(wchar_t c) noexcept
	{
		using namespace impl;
		return is_non_ascii_whitespace(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is whitespace.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_whitespace(wchar_t c) noexcept
	{
		using namespace impl;
		return is_whitespace(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is not whitespace.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_not_whitespace(wchar_t c) noexcept
	{
		using namespace impl;
		return is_not_whitespace(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is a letter from the ASCII range.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_ascii_letter(wchar_t c) noexcept
	{
		using namespace impl;
		return is_ascii_letter(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is a letter from outside the ASCII range.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_non_ascii_letter(wchar_t c) noexcept
	{
		using namespace impl;
		return is_non_ascii_letter(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is a letter.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_letter(wchar_t c) noexcept
	{
		using namespace impl;
		return is_letter(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is a number from the ASCII range.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_ascii_number(wchar_t c) noexcept
	{
		using namespace impl;
		return is_ascii_number(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is a number from outside the ASCII range.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_non_ascii_number(wchar_t c) noexcept
	{
		using namespace impl;
		return is_non_ascii_number(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is a number.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_number(wchar_t c) noexcept
	{
		using namespace impl;
		return is_number(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is a combining mark.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_combining_mark(wchar_t c) noexcept
	{
		using namespace impl;
		return is_combining_mark(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is an octal digit.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_octal_digit(wchar_t c) noexcept
	{
		using namespace impl;
		return is_octal_digit(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is a decimal digit.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_decimal_digit(wchar_t c) noexcept
	{
		using namespace impl;
		return is_decimal_digit(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is a hexadecimal digit.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_hexadecimal_digit(wchar_t c) noexcept
	{
		using namespace impl;
		return is_hexadecimal_digit(static_cast<wchar_unicode_t>(c));
	}

	/// \brief		Returns true if a wide character is a code point boundary.
	/// \ingroup	strings
	[[nodiscard]]
	MUU_ALWAYS_INLINE
	MUU_ATTR(const)
	constexpr bool is_code_point_boundary(wchar_t c) noexcept
	{
		using namespace impl;
		return is_code_point_boundary(static_cast<wchar_unicode_t>(c));
	}

}
MUU_NAMESPACE_END
